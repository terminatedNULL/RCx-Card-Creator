#include "FileWindow.hpp"

const unsigned int FILE_WIND_BUTTONS = 20;

using namespace RCxUI;
using namespace FileW;
using namespace TextTools;

FileWindow::FileWindow(OpenMode mode, int screenW, int screenH)
	: m_mode(mode), m_screenWidth(screenW), m_screenHeight(screenH)
{
	m_style.InitializeFonts();
	setupUI();
}

//=============================================================================================
// INTERACTION FUNCTIONS
//=============================================================================================

/*
 * This is my favorite hack so far, instead of managing a view or re-drawing the background elements on the previous screen,
 * just take a picture of the screen before drawing any of the window elements, then draw that as the abckground until the window closes!
 * And the user is none the wiser...
 */
void FileWindow::Open(sf::RenderWindow& wind) {
	m_active = true;
	sf::Texture backTex;
	sf::Sprite background;

	sf::Vector2u windowSize = wind.getSize();
	backTex.create(sf::VideoMode::getDesktopMode().width, sf::VideoMode::getDesktopMode().height);
	backTex.update(wind);

	background.setTexture(backTex);

	while (m_active) {
		sf::Event event;

		while (wind.pollEvent(event)) {
			HandleEvents(event, wind);
		}

		wind.clear(sf::Color(18, 18, 18));
		wind.draw(background);	
		Draw(wind);
		wind.display();
	}
}

void FileWindow::Close() { 
	m_active = false; 
}

bool FileWindow::IsActive() { 
	return m_active;
}

std::string FileWindow::GetFileDir() {
	return *m_outputDir; 
}

std::string FileWindow::GetFolderDir() {
	return *m_outputDir; 
}

std::vector<std::string> FileWindow::GetAllFileDir() {
	return *m_outputDirVec;
}

//=============================================================================================
// SET FUNCTIONS
//=============================================================================================

void FileWindow::SetFilter(std::string filter) {
	m_extFilter = filter;
}

void FileWindow::SetOutput(std::string* output) {
	m_output = output;
}

void FileWindow::SetOutput(std::vector<std::string>* output) {
	m_outputM = output;
}

//=============================================================================================
// BASE FUNCTIONS
//=============================================================================================

void FileWindow::HandleEvents(sf::Event& event, sf::RenderWindow& wind) {
	switch (event.type) {
	case sf::Event::TextEntered:
		m_directoryBox->TypedIn(event);
		break;
	case sf::Event::MouseButtonPressed:
		if (m_submitDirButton->Click(event, wind) && m_directoryBox->GetText().length() > 0) {
			if (listDirFiles(m_directoryBox->GetText(), m_extFilter, m_fileWindPages)) {
				m_currentPage = 0;
				m_noFiles = false;
				m_fileList = true;
			}
			else { m_noFiles = true; m_fileList = false; }
		}

		if (m_pageButtons[0] && m_nextPageButton->Click(event, wind)) { m_currentPage += 1; }
		if (m_pageButtons[1] && m_prevPageButton->Click(event, wind)) { m_currentPage -= 1; }

		m_directoryBox->Click(event, wind);

		if (m_fileWindClose->Click(event, wind)) { m_active = false; }
		if (m_fileList) {
			std::vector<Button*>* current = &m_fileWindPages[m_currentPage];
			for (int i = 0; i < (*current).size(); i++) {
				if ((*current)[i]->Click(event, wind)) {
					//File selection/unselection handling
					if ((*current)[i]->GetRadioState()) {
						m_fileSelected = true;

						switch (m_mode) {
						case SelectFile:
						case SelectFolder:
						case SaveFile:
							if (m_selectedFiles.size() != 0 && (*current)[i]->GetText().find(m_extFilter) != std::string::npos) {
								m_selectedFiles[0] = (*current)[i];
							}
							else {
								m_selectedFiles.push_back((*current)[i]);
							}
							break;
						case SelectFiles:
						case SelectFolders:
							m_selectedFiles.push_back((*current)[i]);
							break;
						}

						if (m_selectedFiles[0] != nullptr) { m_selectedFiles[0]->SetRadioState(false); }
						m_selectedFiles.push_back((*current)[i]);
					}
					else {
						switch (m_mode) {
						case SelectFile:
						case SelectFolder:
						case SaveFile:
							m_selectedFiles.pop_back();
							break;
						case SelectFiles:
						case SelectFolders:
							m_selectedFiles.erase(
								m_selectedFiles.begin() + std::distance(
									m_selectedFiles.begin(),
									std::find(m_selectedFiles.begin(), m_selectedFiles.end(), (*current)[i])
								)
							);
							break;
						}
					}

					//Check for loading file or directory
					if ((*current)[i]->GetText().find(m_extFilter) != std::string::npos) {
						std::string fullPath = m_directoryBox->GetText() + "\\" + (*current)[i]->GetText();
						m_directoryBox->SetText(fullPath);
						listDirFiles(fullPath, m_extFilter, m_fileWindPages);
					}
				}
			}

			if (m_fileSelected) {
				if (m_selectFilesButton->Click(event, wind)) {
					switch (m_mode) {
					case SelectFile:
					case SelectFolder:
					case SaveFile:
						*m_output = m_selectedFiles[0]->GetText();
						break;
					case SelectFiles:
					case SelectFolders:
						for(Button* btn : m_selectedFiles) {
							std::string text = btn->GetText();
							m_outputM->push_back(text);
						}
					}
				}
			}
		}
		break;
	case sf::Event::MouseButtonReleased:
		m_fileWindClose->Release(event, wind);
		m_submitDirButton->Release(event, wind);
		if (m_fileList) {
			for (int i = 0; i < m_fileWindPages[m_currentPage].size(); i++) { m_fileWindPages[m_currentPage][i]->Release(event, wind); }
			if (m_fileSelected) { m_selectFilesButton->Release(event, wind); }
		}
		if (m_pageButtons[0]) { m_nextPageButton->Release(event, wind); }
		if (m_pageButtons[1]) { m_prevPageButton->Release(event, wind); }
		break;
	case sf::Event::MouseMoved:
		m_fileWindClose->Hover(wind);
		m_submitDirButton->Hover(wind);

		m_nextPageButton->Hover(wind);
		m_prevPageButton->Hover(wind);

		if (m_fileWindPages.size() > 0) {
			for (int i = 0; i < m_fileWindPages[m_currentPage].size(); i++) { m_fileWindPages[m_currentPage][i]->Hover(wind); }
		}
		if (m_fileSelected) { m_selectFilesButton->Hover(wind); }
		break;
	}
}

void FileWindow::Draw(sf::RenderWindow& wind) {

	m_fileWindClose->Draw(wind);
	m_directoryBox->Draw(wind);
	m_submitDirButton->Draw(wind);

	if (m_currentPage == 0 && m_fileList && m_fileWindPages.size() != 1) {
		m_pageButtons[0] = true;
		m_pageButtons[1] = false;
		m_nextPageButton->SetPosition(
			(m_screenWidth / 2) - TextSize("Next Page", m_style.Fonts[SysFonts::SemiBold], 15).x / 2,
			(m_screenHeight / 2) - (m_screenHeight / 1.5) / 2 + (m_screenHeight / 1.5 - 20)
		);
	}
	else if (m_currentPage == m_fileWindPages.size() - 1 && m_fileList && m_fileWindPages.size() != 1) {
		m_pageButtons[1] = true;
		m_pageButtons[0] = false;
		m_prevPageButton->SetPosition(
			(m_screenWidth / 2) - TextSize("Prev Page", m_style.Fonts[SysFonts::SemiBold], 15).x / 2,
			(m_screenHeight / 2) - (m_screenHeight / 1.5) / 2 + (m_screenHeight / 1.5 - 20) - 2
		);
	}
	else if (m_fileList && m_fileWindPages.size() != 1) {
		m_pageButtons[0] = true;
		m_pageButtons[1] = true;
		m_nextPageButton->SetPosition(
			(m_screenWidth / 2) - 77,
			(m_screenHeight / 2) - (m_screenHeight / 1.5) / 2 + (m_screenHeight / 1.5 - 20)
		);
		m_prevPageButton->SetPosition(
			(m_screenWidth / 2) + 2,
			(m_screenHeight / 2) - (m_screenHeight / 1.5) / 2 + (m_screenHeight / 1.5 - 20) - 2
		);
	}
	else if (m_fileList) {
		m_pageButtons[0] = false;
		m_pageButtons[1] = false;
	}

	if (m_noFiles) { wind.draw(*m_noFilesFound); }

	if (m_fileList) { for (Button* b : m_fileWindPages[m_currentPage]) { b->Draw(wind); } }

	if (m_pageButtons[0]) { m_nextPageButton->Draw(wind); }
	if (m_pageButtons[1]) { m_prevPageButton->Draw(wind); }

	if (m_fileSelected) { m_selectFilesButton->Draw(wind); }
}

//=============================================================================================
// INTERNAL FUNCTIONS
//=============================================================================================

void FileWindow::setupUI() {
	m_directoryBox = new Textbox(
		(m_screenWidth / 2) - (m_screenWidth / 3) / 2 + 52,
		(m_screenHeight / 2) - (m_screenHeight / 1.5) / 2 + 30,
		m_screenWidth / 3 - 55, 25, ""
	);
	m_directoryBox->SetFont(m_style.Fonts[SysFonts::Italic]);
	m_directoryBox->SetSingleLine(true);
	m_directoryBox->SetOverflow(false);
	m_directoryBox->SetCharacterSize(20);
	m_directoryBox->BackgroundBorderDetails(TOP_GRADIENT, sf::Color::Transparent, 0);
	m_directoryBox->SetColor(SECONDARY_TEXT);

	m_submitDirButton = new Button(
		(m_screenWidth / 2) - (m_screenWidth / 3) / 2 + 5,
		(m_screenHeight / 2) - (m_screenHeight / 1.5) / 2 + 30,
		45, 25, 0,
		"Load", m_style.Fonts[SysFonts::SemiBold], 17
	);
	buttonBareBones(*m_submitDirButton);
	m_submitDirButton->SetTextOutline(2, sf::Color::Black);

	m_fileWindClose = new Button(
		(m_screenWidth / 2) + (m_screenWidth / 3) / 2 - 22,
		(m_screenHeight / 2) - (m_screenHeight / 1.5) / 2,
		25, 25, 0, "X",
		m_style.Fonts[SysFonts::SemiBold], 15
	);
	m_fileWindClose->SetColors(sf::Color::Transparent, sf::Color::Transparent, sf::Color::Transparent);
	m_fileWindClose->SetTextColors(sf::Color::Black, BACKGROUND, sf::Color::Red);

	m_nextPageButton = new Button(
		(m_screenWidth / 2) - 77,
		(m_screenHeight / 2) - (m_screenHeight / 1.5) / 2 + (m_screenHeight / 1.5 - 20),
		75, 20, 0, "Next Page",
		m_style.Fonts[SysFonts::SemiBold], 15
	);
	buttonBareBones(*m_nextPageButton);

	m_prevPageButton = new Button(
		(m_screenWidth / 2) + 2,
		(m_screenHeight / 2) - (m_screenHeight / 1.5) / 2 + (m_screenHeight / 1.5 - 20) - 2,
		75, 25, 0, "Prev Page",
		m_style.Fonts[SysFonts::SemiBold], 15
	);
	buttonBareBones(*m_prevPageButton);

	m_noFilesFound = new sf::Text("No Files Found In Directory!", m_style.Fonts[SysFonts::Medium]);
	m_noFilesFound->setPosition(sf::Vector2f(
		(m_screenWidth / 2) - (m_screenWidth / 3) / 2 + (m_screenWidth / 6 - m_noFilesFound->getGlobalBounds().width / 2),
		(m_screenHeight / 2) - (m_screenHeight / 1.5) / 2 + (m_screenHeight / 1.5) / 2 - 30
	));
	m_noFilesFound->setFillColor(TOP_GRADIENT);

	m_selectFilesButton = new Button(
		(m_screenWidth / 2) - (m_screenWidth / 3) / 2 + 10,
		(m_screenHeight / 2) - (m_screenHeight / 1.5) / 2 + (m_screenHeight / 1.5 - 20) - 2,
		75, 20, 0, "Select Files",
		m_style.Fonts[SysFonts::SemiBold], 15
	);
	buttonBareBones(*m_selectFilesButton);
}

bool 

std::vector<Button*> FileWindow::generateFileWindButtons(int num) {
	std::vector<Button*> btnList;
	for (int i = 0; i < num; i++) {
		btnList.push_back(new Button(
			(m_screenWidth / 2) - (m_screenWidth / 3) / 2 + 5,
			(m_screenHeight / 2) - (m_screenHeight / 1.5) / 2 + 30 + ((i + 1) * 32),
			m_screenWidth / 3 - 10, 26, 0,
			"TEMPORARY TEXT",
			m_style.Fonts[SysFonts::Book], 17, true
		));
		buttonBareBones(*btnList[i]);
		btnList[i]->SetOutline(2, sf::Color::Black);
	}
	return btnList;
}

void FileWindow::loadFileToUI(std::string path) {
	if (m_extFilter == ".rcrd") {
		/*RCRDFile* loadedFile = loadRCRDFile(path);
		if (loadedFile->IsGood()) {
			//*currentProjectFile = loadedFile;
		}
		else {
			//Throw new error here
			std::cout << "Could not load .rcrd file!\n";
		}*/
	}
}